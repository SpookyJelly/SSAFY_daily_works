# 코드배틀 문제) 11445. 무한 사전
"""
영어 알파벳으로 만들 수 있는 모든 단어(그것이 뜻이 없어도)가 수록된 무한 사전이 있다.
두 단어 P, Q가 주어질 때, 사전 상에서 P와 Q사이에 다른 단어가 있는지 없는지 판별하는 프로그램을 작성하라.

[입력]
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 알파벳 소문자로 이루어진 단어 P가 주어진다.

두 번째 줄에는 알파벳 소문자로 이루어진 단어 Q가 주어진다.
P와 Q의 길이는 1이상 10이하이며, P는 Q보다 사전 상에서 먼저 오는 단어다.
(단, 사전에는 10자보다 더 긴 단어가 존재 할 수 있다.)

[출력]
각 테스트 케이스마다 용사가 사전 상에서 P와 Q사이에 다른 단어가 있다면 “Y”를, 아니면 “N”를 출력한다.

"""

def isit(lst1,lst2):
    # ll의 이유 : 이후 사용할 for 문에서 인덱스 에러를 방지하기 위해 더 짧은 길이를 구한다.
    ll = min(len(lst1),len(lst2))
    # 두 리스트 전체를 조사할 필요 없고, 짧은 길이만큼만 조사하면 된다.
    for idx in range(ll):
        # 만약, lst2와 lst1의 동일 인덱스 값의 ord 차이가 1보다 크거나 같다면, 무조건 참이다.
        # 1. 2 이상인 경우는 둘 사이에 무한한 단어들이 배치 될 수 있다.
        # 2. 1인 경우는 둘 사이에 최소한 1개의 단어가 온다. (입력 조건에 따르면 Q는 P보다 사전 뒤에 오는 단어이므로)
        if ord(lst2[idx]) - ord(lst1[idx]) >= 1:
            return True

        # 그러면 if 문에 들어가지 못한 경우는 ord(lst2[idx]) - ord(lst1[idx]) == 0 하나인데,
        # 이 다음 값을 봐야하므로, 아무런 조건을 설정하지 않는다.


    # 위 for문에서 True를 리턴하지 않은 경우는 lst1[0:ll] == lst2[0:ll] 인 경우이다.
    # 문제의 입력 조건에 따르자면, 이럴때는 무조건 lst2가 lst1보다 길이가 길다.
    # 이러한 경우 False이 되는 경우는 단 하나, lst2와 lst1의 길이 차이가 1이면서, lst2[-1]이 'a' 인 경우 뿐이다.
    # ex. aa / aaa --> 분명 lst2가 lst1의 뒤에 오는 단어인데, 둘 사이에는 어떤 단어도 올 수 없다.
    # 그런 경우만 False를 반환하고, 나머지 경우는 True를 반환해준다.  
    if len(lst2) - len(lst1) == 1 and lst2[-1] == 'a': 
        return False
    else:
        return True

# 이렇게 만들어진 함수로 입력값을 받아 출력한다.
for tc in range(1,int(input())+1):
    # 입력값의 우측 공백을 제거해준다.(순수하게 문자열만을 비교하기 위해서)
    lst1 = list(input().rstrip())
    lst2 = list(input().rstrip())

    if isit(lst1,lst2):
        print(f'#{tc} Y')
    else:
        print(f'#{tc} N')