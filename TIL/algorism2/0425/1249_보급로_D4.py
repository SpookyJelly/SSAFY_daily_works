#1249번 보급로

# 전투에서 승리하기 위해서는 기갑사단과 보급부대가 신속하게 이동하기 위한 도로가 있어야 한다.
# 공병대는 출발지(S) 에서 도착지(G)까지 가기 위한 도로 복구 작업을 빠른 시간 내에 수행하려고 한다.
# 도로가 파여진 깊이에 비례해서 복구 시간은 증가한다.
# 출발지에서 도착지까지 가는 경로 중에 복구 시간이 가장 짧은 경로에 대한 총 복구 시간을 구하시오.
# 깊이가 1이라면 복구에 드는 시간이 1이라고 가정한다.
# 출발지는 좌상단의 칸(S)이고 도착지는 우하단의 칸(G)가 된다.
# 이동 경로는 상하좌우 방향으로 진행할 수 있으며, 한 칸씩 움직일 수 있다.
# 지도 정보에는 각 칸마다 파여진 도로의 깊이가 주어진다. 현재 위치한 칸의 도로를 복구해야만 다른 곳으로 이동할 수 있다.
# 이동하는 시간에 비해 복구하는데 필요한 시간은 매우 크다고 가정한다.
# 따라서, 출발지에서 도착지까지 거리에 대해서는 고려할 필요가 없다.
# 지도 정보는 그림2에서 보듯이 2차원 배열의 형태이다.
# 출발지(S)와 도착지(G)는 좌상단과 우하단이 되고 입력 데이터에서는 0으로 표시된다.
# 출발지와 도착지를 제외한 곳이 0인 것은 복구 작업이 불필요한 곳이다.

# [입력]

# 가장 첫 줄은 전체 테스트케이스의 수이다.
# 각 테스트 케이스마다 지도의 크기(N x N)가 주어진다. 지도의 크기는 최대 100 x 100이다.
# 그 다음줄 부터 지도의 크기만큼 2차원 배열 형태의 지도 정보가 주어진다.

# [출력]

# 주어진 입력에서 출발지에서 도착지까지 가는 경로 중에 복구 작업에 드는 시간이 가장 작은 경로의 복구 시간을 출력하시오.

import sys
sys.stdin = open('1249_input.txt','r')

from collections import deque

def BFS(n):
    D[n][n] = 0
    # 사방 탐색을 해야겠지
    # 상하좌우
    dx = [-1,1,0,0]
    dy = [0,0,-1,1]
    que = deque([[n,n]])
    while que:
        x,y = que.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0<=nx<N and 0<=ny<N:
                if warfare[nx][ny] + D[x][y] < D[nx][ny]:
                    D[nx][ny] = warfare[nx][ny] + D[x][y]
                    que.append([nx,ny])
    return


TC = int(input())

INF = float("inf")
for tc in range(1,TC+1):
    N = int(input())
    # 여태까지의 경로를 표시하는 2차원 배열 D
    D = [[INF] * N for _ in range(N)]
    # 복구 난이도를 나타내는 2차원 배열 
    warfare = [list(map(int,input())) for _ in range(N)]
    BFS(0)
    print('#{} {}'.format(tc, D[N-1][N-1]))

