#1219번 길찾기 (D4)

"""
도시에서 출발하여 B도시로 가는 길이 존재하는지 조사하려고 한다.

길 중간 중간에는 최대 2개의 갈림길이 존재하고, 모든 길은 일방 통행으로 되돌아오는 것이 불가능하다.

다음과 같이 길이 주어질 때,
A도시에서 B도시로 가는 길이 존재하는지 알아내는 프로그램을 작성하여라.

 - A와 B는 숫자 0과 99으로 고정된다.

 - 모든 길은 순서쌍으로 나타내어진다.

위 예시에서 2번에서 출발 할 수 있는 길의 표현은 (2, 5), (2, 9)로 나타낼 수 있다.

 - 가는 길의 개수와 상관없이 한가지 길이라도 존재한다면 길이 존재하는 것이다.

 - 단 화살표 방향을 거슬러 돌아갈 수는 없다.

[제약 사항]

출발점은 0, 도착점은 99으로 표현된다.

정점(분기점)의 개수는 98개(출발점과 도착점 제외)를 넘어가지 않으며,
한 개의 정점에서 선택할 수 있는 길의 개수도 2개를 넘어가지 않는다.
아래 제시된 가이드 라인은 제안사항일 뿐 강제사항은 아니다.

[데이터 저장 가이드]

정점(분기점)의 개수가 최대 100개 이기 때문에,
size [100]의 정적 배열 2개을 선언하여,
각 정점의 번호를 주소로 사용하고,
저장되는 데이터는 각 정점에서 도착하는 정점의 번호를 저장한다.
위 그림을 저장하였을 때 결과는 다음과 같다.

[입력]

각 테스트 케이스의 첫 줄에는
테스트 케이스의 번호와 길의 총 개수가 주어지고 그 다음 줄에는 순서쌍이 주어진다.
순서쌍의 경우, 별도로 나누어 표현되는 것이 아니라 숫자의 나열이며,
나열된 순서대로 순서쌍을 이룬다.


"""
# DFS을 활용하자
# 노드 수 만큼의 visited 만들고, stack 만들고, 으음..아까 그래프 경로와 크게 차이 없어보이는데
# 다만 패스의 수가 2개 고정이라는점만 다르고, 데이터 저장 가이드에 따라, 리스트로 만들라는거..

import sys
sys.stdin = open("1219_input.txt","r")


TC = 10

for _ in range(1,TC+1):
    tc, P = map(int,input().split())
    # print('tc, P : ',tc, P)
    P_lst = list(map(int,input().split()))
    #print(P_lst)
    new = [] # 제멋대로인 input을 쪼개서 출발지점, 종료지점으로 쪼갬
    final = [ [] for _ in range(100)] # 아이고 진짜... [[]]*100 이러니까 shallow copy 됬니까...2차원 배열 쓸 때는 이렇게 range를 이용해서 쓰라고..
    for k in range(0,len(P_lst),2):# 하도 안쓰니까 까먹었는데, for문도 스텝 조절할 수 있다. 2칸씩 건너 뛰면서 final에 값 삽입
        final[P_lst[k]].append(P_lst[k+1])
    #print(final)

    stack =[] # 비어있는 스택 선언
    S,G = 0, 99 # 시작점과 끝점
    visited = [False] * 100 # 각 노드가 방문했는지를 알아보는 구문
    result = 0
    stack.extend(final[0])
    #print(stack)
    while stack:
        way = stack.pop()
        #print(way)
        if way == G :
            result = 1
            break
        # 지금 에러는 way에 하나 밖에 안들어간다? 아...씨발.... 2개 이상 있는 경우는 visited way 들어가면서 True가 되는구나
        for j in range(len(final[way])):
            if not visited[way] and final[way][j]:
                stack.append(final[way][j])
        visited[way] = True # 이러면 될라나? 이야아아아아!!!!!!!!된다!!!!!!!!!
                # 스택에 이미 목표인 99가 있는데도 자꾸 스택을 쌓길래, 여기서 검사 조건을 한번 더 줘봤는데,
                # for j 문만 탈출하고 while문을 탈출하지 못했다. 함수 설계 아니고서야 답이 없는 것인가?
                # if final[way][j] == G:
                #     result = 1
                #     break
    print(f'#{_} {result}')


