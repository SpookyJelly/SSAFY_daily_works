# 4873 반복문자 지우기 (D2)

"""
문자열 s에서 반복된 문자를 지우려고 한다. 지워진 부분은 다시 앞뒤를 연결하는데,
만약 연결에 의해 또 반복문자가 생기면 이부분을 다시 지운다. <-- 이게 중요한 포인트고요
반복문자를 지운 후 남은 문자열의 길이를 출력 하시오. 남은 문자열이 없으면 0을 출력한다.
다음은 CAAABBA에서 반복문자를 지우는 경우의 예이다.


1. CAAABBA 연속 문자 AA를 지우고 C와 A를 잇는다.

2. CABBA 연속 문자 BB를 지우고 A와 A를 잇는다.

3. CAA 연속 문자 AA를 지운다.

4. C 1글자가 남았으므로 1을 리턴한다. <-- 으음....n 글자일때 스답할 수 도 있네.

 # 리스트 하나에서 새로운 리스트로 옮기면서 걸러내야하겠네
 # 옮기는 과정에서 연속문자 발견되면 그 두개의 연속문자는 옮기지 않는다.
 # 그렇게 새로운 문자열 만들었으면 다시 검사... 언제까지?? <-- 이게 중점이다.
 # 한번 쭉 흝었는데, 반복 문자열 없으면 종료하는 while문 만드는게 어떨까?
 # 쭉 흝다가 반복 문자열 나오면 리스트를 갱신해서 다시 검사. <-- set은 쓰면 안된다. SOS 같은 문자열도 중복은 아닌데, 문자는 2개니까


[입력]


첫 줄에 테스트 케이스 개수 T가 주어진다.  1≤T≤ 50

다음 줄부터 테스트 케이스의 별로 길이가 1000이내인 문자열이 주어진다.



[출력]


#과 1번부터인 테스트케이스 번호, 빈칸에 이어 답을 출력한다.


"""

import sys
from typing import List, Any

sys.stdin = open("4873_input.txt","r")

# 푸드 그라인더처럼, stack의 끝값과 lst의 처음값만을 반복해서 비교해주고, 두 값이 같으면
# stack과 lst에서 동시에 그 중복값을 제거해준다. 이를 반복해주면 문제의 요전에 맞는다.
def EbonyBlade(lst:list)->int:
    stack =[]
    idx = 0 # 이친구가 처음값이랑만 비교 하네.
    # lst = lst[1:]
    while lst:
        # 지금 에러나는 이유가 초장부터 겹치는 친구들때문에, 스택이 비어버리는 일이 있음
        # 스택이 비어버리면 자동으로 채워주자.
        if len(stack) == 0:
            stack = [lst[0]]
            lst= lst[1:]
        else:
            if lst[idx] == stack[-1]:
                lst.pop(idx)
                stack.pop(-1)
            else:
                stack.append(lst[idx])
                lst.pop(idx)
    return len(stack)



TC = int(input())

for tc in range(1,TC+1):
    word = list(input())
    print(f'#{tc} {EbonyBlade(word)}')