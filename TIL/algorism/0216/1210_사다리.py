# 1210번 Ladder 1 (D4)

"""
사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 X표시에 도착하게 되는지 궁금해졌다.
이를 구해보자.

아래 <그림 1>의 예를 살펴보면,
출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이
랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이
또한 랜덤하게 연결된다.

X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이,
아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.

방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.
문제의 X표시에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다.
해당 경로는 별도로 표시하였다.

아래 <그림 2>와 같은 100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서,
지정된 도착점에 대응되는 출발점 X를 반환하는 코드를 작성하라
(‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다. 도착 지점은 '2'로 표현된다).

[제약 사항]
한 막대에서 출발한 가로선이 다른 막대를 가로질러서 연속하여 이어지는 경우는 없다.

[입력]
입력 파일의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며,
바로 다음 줄에 테스트 케이스가 주어진다.
총 10개의 테스트 케이스가 주어진다.

[출력]

#부호와 함께 테스트 케이스의 번호를 출력하고,
공백 문자 후 도착하게 되는 출발점의 x좌표를 출력한다.


"""
# 접근방법
# 0. while문 사용하는게 나을듯 / 웜푸스 게임이라 비슷하게 가보자.
# 1. 움직임을 어떻게 표현해야할까? pointer 라는 변수로 지정하자.
# 2. 시작점은 어떻게 정할까? --> arr[0] 쭉 스캔해서 값이 1인 부분반환 받음
# 2.1. 아니면....if arr[0][i]: 조건으로 시작? (for i in range(100)) --> 나쁘지 않아보여
# 3. arr[0][i]인 경우에서 --> arr[a][i] a는 점점 커지는데, if arr[a][i+1] or arr[a][a-1] == 1


# 후기
"""
와... 어떻게 문제 하나하나가 레전드냐

교수님 힌트 없었으면 진짜 풀지도 못했을 것이다...

접근법

# 1. 시작점이 아니라 끝 점 (데이터 값이 2인 지점)에서부터 거슬러 올라 가서 시작점을 찾는 방식으로 간다.
# 2. 포인터 개념을 이용하지 않고, while문을 이용한 방향 전환을 시도함 (<-- 이거 진짜 천재적인 아이디어)

"""



import sys
sys.stdin = open('input.txt','r')


TC = 10
for tc in range(1,TC+1):
    t = int(input())
    arr = [list(map(int,input().split())) for x in range(100)]
    N = len(arr)

    for idx in range(N):
        if arr[99][idx] == 2:
            start = idx

    start_row = 99
    start_col = start

    #print(f'start_row :{start_row}, start_col : {start_col}')

    # 데이터 2가 들어가있는 arr의 위치
    end_point = arr[start_row][start_col]
    while True:
        # 일단 앞으로, 어짜피 end_point에서도 무조건 첫걸음은 앞으로 가는게 맞다.
        start_row -= 1
        # 만약에, 이러한 -1 정책으로 start_row가 0이 된다면, (첫행에 도달한다면) break 해준다
        if start_row <= 0:
            #print(start_col)
            break
        # 만약  현재 위치의 오른쪽 데이터가 1이면?
        # 현재 위치를 오른쪽을 1칸 옮겨주는데,
        # 근데 여기서 중요한것은, 과도한 뺑뺑이로 start_col이 99를 초과할 수 있는데,
        # 이를 and 조건으로 막아줘야한다. 여기서 더 중요한 것은, a and b 조건에서, 인터프리터는
        # a를 먼저 확인하기에, a에 범위 조건을 넣어, b에서 인덱스 에러가 나지 않게 해야한다.
        if start_col<99 and arr[start_row][start_col+1]:
            # 오른쪽의 위치가 0이 나올때까지 뺑뻉이 돌려준다
            while arr[start_row][start_col+1]:
                start_col += 1
                # 순환중에도 start_col이 99 이상이 될 수도 있으니, while문 내부에도 break 조건을 걸어야한다.
                if start_col+1 >= 99:
                    break
        # 만약 왼쪽이 1이면? 상동하다. 왼쪽에 1이 나오지 않을때까지 뺑뺑이를 돌리는데,
        # 범위를 벗어나지 않도록 and 앞에 범위 조건을 달아준다.
        # 근데 왼쪽 열에 대해서는 범위 조건이 없어도 정상출력이 되는데, input값의 우연의 일치로 그렇게 된거지, 이거 있어야하는게 맞다
        elif start_col>=0 and arr[start_row][start_col-1]:
            while arr[start_row][start_col-1]:
                start_col -= 1
                # 순환중에도 start_col이 0 이하가 될 수도 있으니, while문 내부에도 break 조건을 걸어야한다.
                if start_col-1 < 0:
                    break
    print(f'#{tc} {start_col}')



# 교수님의 힌트 우선순위를 잘 잡아라.--> 우선순위는 좌 우로 가는거.
# 아, 가로로 몇줄 이상 가는거..! 거기에서 중간에 처한 친구는 어떻게 처리할껀가 생각해라
# 기본 구조는 어떻게 생각???

"""
while yp < 99 :
# 방향이 필요한 경우, 방향을 뜻하는 변수 하나 잡아줘라 
# ex d: 0 -> 위에서 온거 
# ex d: 1- >왼쪽에서 온거... 이런식으로 
# ex d : 2 -> 오른쪽에서 온거
if 왼쪽 체크 and 왼쪽이나 위에서 왔으면 (이걸 pointer 사용)
xp -= 1
d =
elif 오른쪽 체크 and 오른쪽이나 위에서 왔으면
xp += 1
d = 
elif 아래쪽 체크

yp +=1
d = 
if BRD [yp][xp] == 2:
return True

return False


아니면 거꾸로 가는걸 생각해보자..

"""