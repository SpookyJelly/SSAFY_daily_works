# 1216번 회문2 (D3)

"""
주어진 100*100 평면 글자판에서 가로,세로를 모두 보아 가장 긴 회문의 길이를 구하는 문제이다.
[제약사항]

각 칸의 들어가는 글자는 c언어 char type으로 주어지며 'A', 'B', 'C' 중 하나이다.

글자 판은 무조건 정사각형으로 주어진다.

ABA도 회문이며, ABBA도 회문이다. A또한 길이 1짜리 회문이다.
가로, 세로 각각에 대해서 직선으로만 판단한다.
즉, 아래 예에서 노란색 경로를 따라가면 길이 7짜리 회문이 되지만
직선이 아니기 때문에 인정되지 않는다.

[입력]

각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며,
바로 다음 줄에 테스트 케이스가 주어진다.
총 10개의 테스트케이스가 주어진다.

[출력]

#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 찾은 회문의 길이를 출력한다.

"""

# 접근 방법
# 길이 M인 회문을 N*N 크기의 자판에서 확인하는데, 길이 M이 체크하면서 점점 줄여나가면 될듯

# 함수의 목적 : BRD에 M 길이의 회문이 존재하는가??
# BRD가 함수내에 정의되어있지 않은데, 스코프 규칙에 따라서 함수 밖에서 가져올 수도 있다.
def allChk(M):
    # i는 이 함수를 몇번 반복할지를 결정. N == 100 (len(BRD)) 이므로, 모든 경우에 대해 분석한다고 생각하자.
    for i in range(N):
        # j는 요소의 검사를 시작할 위치를 결정. 검사 대상인 회문의 길이가 M이므로, 최대 크기는 N-M / 최소 크기는 0 이 되어야한다. 그렇기때문에 range(N-M+1)
        for j in range(N - M + 1):

            # 행 대상 검사
            # pos는 값을 더해가며 회문 여부를 검사하는 변수이다. pos의 값 변화에 따라, 문자열 검사하는 위치가 달라진다.
            pos = 0
            # 처음값과 끝값이 같으면 pos 값이 오르는데, 이 값이 M//2가 되면 탈출하게 된다. 만일 처음값과 끝값이 다르면, pos값이 오르지 않고, 이하의 if문을 만족하지 못해 다음 j값으로 넘어간다.
            while pos < M // 2 and BRD[i][j + pos] == BRD[i][j + M - 1 - pos]:
                pos += 1
            if pos == M // 2:
                return M

            # 열 대상 검사
            pos = 0
            # 행 검사와 동일하나, j의 위치가 바뀌었다.
            while pos < M // 2 and BRD[j + pos][i] == BRD[j + M - 1 - pos][i]:
                pos += 1
            if pos == M // 2:
                return M
    # 만약에 100번 검사를 끝마쳤는데도, 회문을 찾지 못하면 0을 반환한다.
    return 0


TC = 10
for tc in range(1, TC + 1):
    t = input()
    N = 100  # BRD의 길이, 정사각형 꼴이므로, 그냥 정수형으로 정의해도 된다.
    BRD = [input() for _ in range(100)]

    retV = 0
    # M이 높은 곳에서부터 내려온다. 반환값은 0 or M이므로, 먼저 등장하는 M이 최대값임은 자명하다
    for l in range(100, 1, -1):
        # 그렇기에 allChk가 0보다 크면(M을 return하면)
        if allChk(l) > 0:
            # 그때의 l을 retV로 하고
            retV = l
            # allChk 돌리기를 그만 둔다
            break

    # 이후 출력
    print('#{} {}'.format(tc, retV))



