# 1258번 행렬찾기

"""
창고에는 화학 물질 용기 n2개가 n x n으로 배열되어 있었다.

유엔 조사단은 각 용기를 조사하여 2차원 배열에 그 정보를 저장하였다.

빈 용기에 해당하는 원소는 ‘0’으로 저장하고, 화학 물질이 들어 있는 용기에 해당하는 용기는 화학 물질의 종류에 따라
‘1’에서 ‘9’사이의 정수를 저장하였다.

1. 화학 물질이 담긴 용기들이 사각형을 이루고 있다. 또한, 사각형 내부에는 빈 용기가 없다.
예를 들어, 위의 그림에는 3개의 화학 물질이 담긴 용기들로 이루어진 사각형 A, B, C가 있다.

2. 화학 물질이 담긴 용기들로 이루어진 사각형들은 각각 차원(가로의 용기 수 x 세로의 용기 수)이 다르다.

3. 2개의 화학 물질이 담긴 용기들로 이루어진 사각형들 사이에는 빈 용기들이 있다.

단, A와 C의 경우와 같이 대각선 상으로는 빈 용기가 없을 수도 있다.

n은 100 이하이다. # 각 테스트 케이스는 n+1줄 구성, 첫줄에는 양의 정수 n 이 주어지고, 다음 n줄에는 n*n행렬이 주어짐
부분 행렬의 열의 개수는 서로 다르며 행렬의 행의 개수도 서로 다르다.
예를 들어, 3개의 부분행렬 행렬 (A(3x4), B(2x3), C(4x5))이 추출되었다면, 각 부분 행렬의 행의 수는 3, 2, 4로 서로 다르다.
마찬가지로 각 부분 행렬의 열의 수도 4, 3, 5로 서로 다르다.

테스트 케이스는 여러 개의 그룹으로 구성되며 아래와 같다.
그룹 1. n <= 10 이고 sub matrix의 개수 5개 이하
그룹 2. n <= 40 이고 5 < sub matrix <= 10
그룹 3. 40 < n <=80 이고 5 < sub matrix <= 10
그룹 4. 40 < n <=80 이고 10 < sub matrix <= 15
그룹 5. 80 < n<=100 이고 15 < sub matrix <= 20

[출력]

각 테스트 케이스 각각에 대한 답을 출력한다.
각 줄은 ‘#x’로 시작하고 공백을 하나 둔 다음,
각 테스트 케이스에 주어진 행렬에서 추출된 부분 행렬들을 개수와
그 뒤를 이어 행렬들의 행과 열의 크기를 출력한다.

크기는 행과 열을 곱한 값으로, 크기가 작은 순서대로 출력한다.
예를 들어 3x4 행렬의 크기는 3*4 = 12 이다.

크기가 같을 경우 행이 작은 순으로 출력한다.
예를 들어 12x4, 8x6 두 개의 행렬은 같은 크기이고 행은 각각 12, 8 이므로 8 6 12 4 순으로 출력한다.

"""

# sub-matrix 갯수 출력 --> sub-matrix의 행/열을 한줄로 출력하는 것이다.

# DFS를 이용해서 풀어볼라고 하는데...위로 움직이거나 아래로 움직이면 row를 하나 증가 , 왼쪽/ 오른쪽 움직이면 col 하나 증가
# 이동하면서 덧씌워준다.
# 시작 지점은 어떻게 구하지? 그냥 1,1부터 시작하게 할까? -> 아니야 시작 지점 구해서 집어넣어준다음에, 더 못 꺼내면 return으로 행/열 반환하게 하자.
# 1행 1열부터 쭉 서치하다가, 0이 아니면 행렬구하는 함수로 보냄.

import sys

sys.stdin = open('1258_input.txt', 'r')


# 기본 아이디어 :
# DFS를 이용해 sub-martix를 찾자.
# sub-martix가 모두 사각형이라는 것에 주목 -> x좌표와 y좌표의 최대값을 구한 다음, 검색 시작점과의 차이를 구하면 두 좌표 사이의 distance가 나오겠지.
# 만일 sub-matrix가 오각형이던가 하면 문제가 되는 아이디어이긴 하다.

def subM(start: list):
    # 델타 무브 상하좌우
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    stack = [start]
    max_x = start[0]
    max_y = start[1]
    while stack:
        r, c = stack.pop()
        arr[r][c] = 0  # 일단 자기자신부터 방문처리 해준다. / 이동하면서 arr을 변경할 것이기 때문에 visited 행렬은 필요없다.
        for i in range(4):
            nr = r + dx[i]
            nc = c + dy[i]
            if 0 <= nr < N and 0 <= nc < N and arr[nr][nc] != 0:
                stack.append([nr, nc])
                if nr > max_x:
                    max_x = nr
                if nc > max_y:
                    max_y = nc

    row = max_x - start[0] + 1
    col = max_y - start[1] + 1
    return [row, col, row * col]


TC = int(input())
for tc in range(1, TC + 1):
    result = []
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # arr을 검색하다가, 0이 아닌 부분이 나오면 subM으로 보낸다.
    for R in range(N):
        for C in range(N):
            if arr[R][C]:
                result.append(subM([R, C]))

    # 위의 아이디어는 좋았다. 그럼 이걸 이제 어떻게 정렬하는가인데, sort와 key 매개변수를 이용하여 정렬하기로 하였다.
    """
    key는 함수를 받는다. 따라서 익명함수인 lambda와 결합하면, lambda의 결과값을 기준으로 정렬을 해준다.
    현재 result는 [[2,4,6],[3,4,5]....] 꼴의 2차원 배열로 형성 되어있다.
    여기서 lambda를 사용한다면, 2차원 배열을 구성하는 요소들의 값을 하나하나 꺼내서 비교할 수 있다.
    
    
    key = lambda x : (x[2],x[0])
    
    이 코드에서 lambda의 역할은 result 리스트의 요소들을 x로 삼아 (x[2],x[0])을 꺼내 key에게 준다.
    
    key = (x[2],x[0])
    
    key 위치 인자는 함수를 받으면 함수에서 지정한 결과값에 따라서 정렬을 할 수 있다.
    때문에, lambda의 결과값인 x[2], x[0]을 인자로 삼아 x[2]를 기준으로 오름차순 정렬(만일 x[2]가 동일하다면 x[0] 기준으로 오름차순)을 해준다.
    
    그러면 왜 lambda x 위치에 result의 요소가 들어가는 이유가 궁금할 수도 있겠는데,
    그건 아마 .sort()함수가 iterable 한 요소를 언패킹해서 정렬하도록 설계되어있어서 그런게 아닐까라고 조심스럽게 추측해본다    
    아무튼, 중요한 부분은 sort와 lambda의 결합이고, 확실히 내 것으로 만들자.
    
    """
    # 생각해보니까, 함수에서 return할때, 넓이 , 행 , 열 순서로 했으면, lambda 쓸 필요도 없었네, 붓다!!!
    result.sort(key=lambda x: (x[2], x[0]))

    print('#{0} {1}'.format(tc, len(result)), end=' ')
    for idx in range(len(result)):
        print(result[idx][0], result[idx][1], end=' ')
    print()
