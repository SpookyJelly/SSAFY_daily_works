# 1859번 백만장자 프로젝트 (D2)
# N일까지의 시세를 알때, 최대의 수익을 구하라
# 물건은 하루에 하나씩만 살 수 있지만, 판매에는 제한이 없다.


TC = int(input())

for tc in range(1,TC+1):
    N = int(input()) 
    price = list(map(int,input().split()))
    result = 0
    
    # 요지는, 뒤에서부터 보는 것이라고 한다.
    # 앞에서부터 살피게 된다면, 오늘 산 물건이 다음날 파는게 이득이더라도, 다다음, 다다다음 날에 파는 것보다 이득인지 대소분간을 해야하는데,
    # 뒤에서부터 살피면, 한번 최대값을 찾으면, 다른 최대값이 나오기전까지의 판매는 모두 이득이 되는 것을 확연히 알 수 있다.
    # 그리고 그 이득의 정도는 최대값 - 구매당시 가격으로 계산이 된다.
    # 다른 최대값이 나오는지 확인함과 동시에, 이득을 계산하니, 실행 속도가 훨씬 더 빠를 수 밖에 없다.
    
    # 최초의 최대값은 price의 가장 뒤의 요소이다.
    max_price = price[N-1]
    # 그리고 뒤에서부터 앞으로 가면서 요소들을 살펴보는데,
    for i in range(N-1,-1,-1):
        # 만약 i번째 요소가 최대값보다 작다면, i번째 날에 구매한 물건은 max_price의 날에 판매한다면 최대의 이득을 보는 것이니 
        if max_price>price[i]:
            # 결과값에 둘의 차이를 더해준다.
            result += max_price-price[i]
        # 만일 i번째 요소가 현재의 max_price보다 크다면, 최대값을 바꾼 후, 루프를 반복한다.
        else:
            max_price = price[i]

            
     # 타임에러 난 코드.
    # 모든 요소에 대해서 어느 지점에서 팔아야 고점인지를 판별하고, 그 고점에서 판매한 수익을 더해주는 방식이다.
    # 근데 이는 for문으로 그 이후의 값과의 값 비교를 시행하기때문에
    # 최대 백만-1 * 백만-1 번의 반복을 시행하게 됨. 느려질수 밖에 없다. 
    
    # for i in range(N-1):
    #     maxi = 0
    #     for j in range(1+i,N):
    #         if price[j] - price[i] > maxi:
    #             maxi = price[j] - price[i]
    #     result += maxi
    print('#{} {}'.format(tc, result))