# 4837. 부분집합의 합

>  이해하는데 굉장히 어려웠고, 여러모로 생각할 거리가 많은 문제였다.
>
> 풀때는 진짜 열불 터졌지만, 다 풀고 나니 비트 연산자에 대한 이해를 높힐 수 있던 좋은 문제라고 생각한다.



1. 핵심 키워드

   >  & : Bitwise 연산자. 앞 뒤로 온 정수를 2진수로 바꿔서 겹치면 그대로, 아니면 0으로 변환해서 반환해준다. (즉, 둘 다 참일때만 만족한다는 소리이다.)

   ```
   예시)
   
   1. 3 & 2의 연산 진행과정 
   
   - 3 & 2
   
   - 11(2) & 10(2) 
   
   - 10(2)
   
   - 2
   
   앞자리의 1은 서로 동일하므로, 1을 그대로 반환하고, 뒤자리는 1, 0으로 서로 다르니 0을 반환한다.
   
   
   2. 3 & 4의 연산 진행 과정
   
   - 3 & 4
   
   - 11(2) & 100(2)
   
   - 0(2)
   
   - 0
   
   만일 두 정수의 자리수가 다르다면, 모자란 부분이 자동으로 0으로 채워진다고 생각하면 편하다.
   
   
   3. 4 & 5의 연산 진행 과정
   
   - 4 & 5
   
   - 100(2) & 101(2)
   
   - 100(2)
   
   - 4
   
   가운데 0도 서로 겹치는 부분이니까 반환 된다고 설명하려고 했는데, 둘 다 참 일때만 참이라는 & 의 조건을 생각해보면, 0끼리는 겹쳐도 반환 안된다고 해석해도 될 듯하다.
   ```

   

   > << , >> : 시프트 연산자. 변수의 값을 왼쪽으로 지정된 비트수 만큼 이동

   ```
   예시
   
   1. 1<<2
   
   - 1(2) << 2 
   
   - 100(2)
   
   - 4
   
   1을 왼쪽으로 두칸 밀어주고, 빈 자리를 0으로 채워준다고 생각하면 된다.
   
   2. 5<<2
   
   - 101(2) << 2
   
   - 10100(2)
   
   - 20
   
   결국, a<<b 는 a * 2^b와 동일하다
   
   
   3. 4>>1
   
   - 100(2) >> 1
   
   - 10(2)
   
   - 2
   
   오른쪽으로 한 칸씩 밀어준다.
   
   4. 4 >> 3
   
   - 100(2) >> 3
   
   - 0(2)
   
   - 0
   
   만약에 오른쪽으로 이동시켰을 때, 1이 들어갈 공간이 없다면 1은 사라진다. 즉, 계속 비트를 오른쪽으로 이동시킨다면, 1은 모두 사라지고 최종적으로는 0이 된다.
   ```



* 이 두 개념을 머리 속에 잘 새긴 채 아래 코드를 살펴보자.



```python
arr = [a,b,c]
n = len(arr) # 3
for i in range(1<<n): # 1<<n -> 1<<3 -> 2^3 -> 8
    for j in range(n):
        if i&(1<<j): # 1<<j : 0, 1, 10 3가지 경우를 반복한다
        	print(arr[j], end='')
    print()
```



- 코드의 기본 골자는, arr의 인덱싱 하여, 부분집합으로 만드는 것이다. i에 따라, if문을 1개 이상 만족 시킬 수 있고, 만족하는 경우를 출력하는 것인데, 실제 예시를 들어서 설명하겠다.



```python
arr = [a,b,c]
n = len(arr) # 3


# i == 3 인 경우


for i in range(1<<n): 
    for j in range(n):
    # j == 0,1,2   
        if i&(1<<j): 
            print(arr[j], end=' ')
    # 1번째 루프 (j == 0)
    # i&(1<<j) --> 3&(1<<0) --> 11(2) & 1(2) --> 1(2) --> 1 --> True
    # j == 0 일때 True 이므로, if문이 실행된다.
    # print(arr[0], end = ' ')
    
    # 2번째 루프 (j == 1)
    # i &(1<<j) --> 3&(1<<1) --> 11(2) & 10(2) -->10(2) --> 2 --> True
    # j == 1 일때 True 이므로, if문이 실행된다.
    # print(arr[1], end = ' ')
    
    # 3번째 루프 (j == 2)
    # i & (1<<j) --> 3&(1<<2) --> 11(2) & 100(2) --> 0(2) --> 0 --> False
    # j ==2 일때 False이므로, if문이 실행되지 않는다.
    
    print()
    
# 그 결과, i ==3 일때의 출력은 a b 가 된다.
```

이런 방식으로 arr의 부분집합을 뽑아 낼 수 있다.

여기서 중요한 점은 ```i == 1<<n```이라는 점인데, 길이가 n인 집합이 가질 수 있는 부분 집합은 2^n 개이다.

그렇기 때문에 2^n 번 루프를 반복하면서 arr의 부분집합을 모두 뽑아내야한다.

i를 1<<n으로 설정하면, 입력되는 리스트의 길이에 맞게 반복횟수를 정해진다는 사실도 기억하자.  



이번 문제의 핵심 파트인 부분집합 반환 코드를 이해했으니, 이제 문제 조건에 맞게 변형하자.



```python
def bitlst(lst:list) -> list:
    n = len(lst)
    result = []
    for i in range(1<<n):
        temlst = []
        for j in range(n):
# i j 비교할때마다 하나씩 반환이 되는데, 우리는 부분집합을 원하므로, 임시 저장소에 하나씩 저장해놨다가
            if i & (1<<j):
                temlst.append(lst[j])
        # for j 루프가 끝나면 한번에 result로 append 해주자
        result.append(temlst)
    # 그러면 부분집합만이 모인 result를 반환할수 있다.
    return result


for tc in range(1,int(input())+1):
    N,K = map(int,input().split())
    cnt = 0
    # 문제 조건에 따라 A는 1~12를 가진 리스트이다.
    lst_N= list(range(1,13))
    test_case = bitlst(lst_N)
    print(test_case)
    for element in test_case:
        # 만약 bitlst를 돌린 test_case의 요소의 합이 K이고, 그 길이도 N 이라면 cnt +=1
        if sum(element) == K and len(element) == N:
            cnt += 1
            print(element)
    print(f'#{tc} {cnt}')


```





### 강평

---

구글링으로 파이썬으로 부분 집합 구하는 방법을 여럿 찾아봤는데, 예시 리스트의 리터럴이 전부 숫자로 되어있어서 더 헷갈렸던 것 같다. 문자 리터럴로 구성된 리스트로 살펴보니 이해가 좀 잘되었다.



무사히 풀고 나서 드는 생각인데, 이런 해법을 생각한 사람은 진짜 천재인거 같다...어후